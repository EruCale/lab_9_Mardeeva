{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "2de07442-cd24-4d70-b595-b01afc344a22",
   "metadata": {},
   "source": [
    "---\n",
    "title: 'Лабораторна робота №9. Рядки. Методи рядків і списків. Частина І'\n",
    "description:\n",
    "   Документ зроблено за допомогою [Quarto](https://quarto.org/)\n",
    "author: \"&copy; [<span style='color: black;'> Мардєєва Діана </span>]), 2024\"\n",
    "date: \"02.12.2024\"\n",
    "lang: ukr\n",
    "format:\n",
    "  html:\n",
    "    code-fold: true\n",
    "    toc: true # меню\n",
    "    toc_float: # спливаюче меню  \n",
    "      collapsed: true # авто\n",
    "      number_sections: true\n",
    "jupyter: python3\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bdf9640d-0762-4755-a9d8-61ef91ff1855",
   "metadata": {},
   "source": [
    "__Мета:__ _навчитися обробляти рядки за допомогою спеціальних функцій і методів._"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a943e6f2-1fb3-4fea-a607-00befb521007",
   "metadata": {},
   "source": [
    "## Основні методи та функції для обробки рядків"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cab4bdb9-20bb-4367-943c-bdeb3caf9d1f",
   "metadata": {},
   "source": [
    "### Основні методи для обробки рядків"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b20fed7b-e348-4e4c-b2a6-717313998a5d",
   "metadata": {},
   "source": [
    "- capitalize() – замінює всі мали букви на великі;\n",
    "- center() – центрує рядок всередині поля відомої довжини;\n",
    "- count() – рахує кількість входжень даного символу в рядку;\n",
    "- join() – з’єднує всі елементи кортежу/списку в один рядок;\n",
    "- lower() – перетворює всі літери рядка на малі;\n",
    "- lstrip() – видаляє білі символи з початку рядка;\n",
    "- replace() – замінює задану підрядок іншим;\n",
    "- rfind() – знаходить підрядок, пошук починається з кінця рядка;\n",
    "- rstrip() – видаляє білі символи з кінця рядка;\n",
    "- split() – розбиває рядок на підрядки з використанням заданого роздільника;\n",
    "- strip() – видаляє білі символи з початку і кінця рядка;\n",
    "- swapcase() – змінює регістр літер на протилежний (малі на великі і навпаки);\n",
    "- title() – робить першу літеру в кожному слові великою;\n",
    "- upper() – перетворює всі літери рядка на великі."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "81843d6d-b3cf-4de4-adea-867a44ea16ac",
   "metadata": {},
   "source": [
    "### Аналіз вмісту рядків"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "07093b9a-39bb-4c66-be75-c72d6ba09e79",
   "metadata": {},
   "outputs": [],
   "source": [
    "Содержимое строки можна визначити за допомогою наступних методів (вони повертають логічні значення):\n",
    "\n",
    "- endswith() - закінчується рядок заданою підстрокою?\n",
    "- isalnum() - складається рядок лише з букв і цифр?\n",
    "- isalpha() - складається рядок лише з букв?\n",
    "- islower() - складається рядок лише з малих літер?\n",
    "- isspace() - складається рядок лише з пробільних символів?\n",
    "- isupper() - складається рядок лише з великих літер?\n",
    "- startswith() - починається рядок з даної підстроки?"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "42108cb1-d131-4b68-b4fc-1540b6cbedd4",
   "metadata": {},
   "source": [
    "### Приклад 1"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2974fb3f-fb0b-4683-878b-148c63bb5049",
   "metadata": {},
   "source": [
    "Написати власну функцію, яка працює практично так само, як оригінальний метод 'split()', а саме:\n",
    "\n",
    "вона повинна приймати рівно один аргумент - рядок;\n",
    "вона повинна повертати список слів, які можна створити з даного рядка, розділивши його пробілами;\n",
    "якщо рядок порожній, функція повинна повертати порожній список;\n",
    "ім’я функції 'mysplit()'.\n",
    "Використовуйте шаблон у редакторі. Добре протестуйте свій код."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "abf5f309-17a5-45f0-b2c4-24e62a14d4fb",
   "metadata": {},
   "outputs": [],
   "source": [
    "def mysplit(string):\n",
    "    string = string.strip()\n",
    "    if string == \"\":\n",
    "        return []\n",
    "    result = []\n",
    "    word = \"\"\n",
    "    for char in string:\n",
    "        if char.isspace():\n",
    "            if word:\n",
    "                result.append(word)\n",
    "                word = \"\"\n",
    "        else:\n",
    "            word += char\n",
    "    if word:\n",
    "        result.append(word)\n",
    "\n",
    "    return result\n",
    "\n",
    "print(mysplit(\n",
    "    \"To be or not to be, that is the question\"))\n",
    "print(mysplit(\"   \"))\n",
    "print(mysplit(\" abc \"))\n",
    "print(mysplit(\"\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "acb1bc19-844b-4b79-b79a-34ca1b1c8ff8",
   "metadata": {},
   "outputs": [],
   "source": [
    "['To', 'be', 'or', 'not', 'to', 'be,', 'that', 'is', 'the', 'question']\n",
    "[]\n",
    "['abc']\n",
    "[]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0faeccdb-4669-4ec6-87b3-d66d6744dc5d",
   "metadata": {},
   "source": [
    "### Очікуваний вивод"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "85e4a396-7f9b-494e-a8ed-5767d8a62f94",
   "metadata": {},
   "source": [
    "'['To', 'be', 'or', 'not', 'to', 'be,', 'that', 'is', 'the', 'question']\n",
    "[]\n",
    "['abc']\n",
    "[]'"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "78c8a86e-fd28-4b88-95f7-9e2d43af3584",
   "metadata": {},
   "source": [
    "### Приклад 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "86b8e1f2-877f-49e5-8873-f8a31615d3ba",
   "metadata": {},
   "outputs": [],
   "source": [
    "Ви, дійсно, бачили семисегментний дисплей.\n",
    "\n",
    "Це пристрій (іноді електронний, іноді механічний), який призначений для відображення однієї десяткової цифри за допомогою підмножини з семи сегментів. Якщо ви все ще не знаєте, що це таке, зверніться до статті у Вікіпедії.\n",
    "\n",
    "Ваше завдання - написати програму, яка здатна імітувати роботу пристрою з семисегментним дисплеєм, хоча краще все ж таки використовувати окремі світлодіоди замість сегментів.\n",
    "\n",
    "Кожна цифра складається з 13 світлодіодів (деякі горять, деякі вимкнені).\n",
    "Примітка: цифра 8 показує всі світлодіоди, які включені.\n",
    "\n",
    "Ваш код повинен відображати будь-яке невід’ємне ціле число, введене користувачем."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "923212b9-b8b8-4200-bf6c-fbdedcffa601",
   "metadata": {},
   "outputs": [],
   "source": [
    "def display_digit(digit):\n",
    "    segments = {\n",
    "        '0': [\" *** \", \"*   *\", \"*   *\", \"*   *\", \" *** \"],\n",
    "        '1': [\"  *  \", \" **  \", \"  *  \", \"  *  \", \" *** \"],\n",
    "        '2': [\" *** \", \"    *\", \" *** \", \"*    \", \"*****\"],\n",
    "        '3': [\" *** \", \"    *\", \" *** \", \"    *\", \" *** \"],\n",
    "        '4': [\"   * \", \"  ** \", \" * * \", \"*****\", \"   * \"],\n",
    "        '5': [\"*****\", \"*    \", \" *** \", \"    *\", \" *** \"],\n",
    "        '6': [\" *** \", \"*    \", \"**** \", \"*   *\", \" *** \"],\n",
    "        '7': [\"*****\", \"    *\", \"   * \", \"  *  \", \"  *  \"],\n",
    "        '8': [\" *** \", \"*   *\", \" *** \", \"*   *\", \" *** \"],\n",
    "        '9': [\" *** \", \"*   *\", \" ****\", \"    *\", \" *** \"],\n",
    "    }\n",
    "    return segments.get(digit,\n",
    "                        [\"     \", \"     \", \"     \", \"     \", \"     \"])\n",
    "\n",
    "def display_number(number):\n",
    "    digits = str(number)\n",
    "    rows = [\"\"] * 5\n",
    "    for digit in digits:\n",
    "        digit_rows = display_digit(digit)\n",
    "        for i in range(5):\n",
    "            rows[i] += digit_rows[i] + \"  \"\n",
    "    for row in rows:\n",
    "        print(row)\n",
    "\n",
    "num = input(\"Введіть цифри для відображення на семисегментному дисплеї: \")\n",
    "display_number(num)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8a1769af-704e-464e-a74d-e2f86d4384ce",
   "metadata": {},
   "outputs": [],
   "source": [
    "Введіть цифри для відображення на семисегментному дисплеї: >? 2478129\n",
    " ***      *   *****   ***     *     ***    ***   \n",
    "    *    **       *  *   *   **        *  *   *  \n",
    " ***    * *      *    ***     *     ***    ****  \n",
    "*      *****    *    *   *    *    *          *  \n",
    "*****     *     *     ***    ***   *****   ***"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "87912964-8f12-4825-88b9-3f6b3162aff1",
   "metadata": {},
   "source": [
    "### Приклад 3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d17687ec-0949-4d0b-84fc-8a4b091edabf",
   "metadata": {},
   "outputs": [],
   "source": [
    "Шифр Цезаря\n",
    "Цей шифр був (мабуть) винайдений і використаний Гаєм Юлієм Цезарем та його військами під час Галльських війн. Ідея досить проста - кожна буква повідомлення замінюється на найближчу наступну (A стає B, B стає C тощо). Єдиним виключенням є буква Z, яка стає A.\n",
    "\n",
    "Напишіть програму для шифрування поввідомлення, використовуючи такі припущення:\n",
    "\n",
    "- вона приймає лише латинські літери (примітка: римляни не використовували пробіли, ні цифри);\n",
    "- всі літери повідомлення знаходяться у верхньому регістрі (примітка: римляни знали лише великі літери)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b3331c78-e16a-4ae9-a43a-9cb076fa8a23",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Task3\n",
    "def caesar_cipher(message, shift=1):\n",
    "    encrypted_message = \"\"\n",
    "    for char in message:\n",
    "        if 'A' <= char <= 'Z' or char == ' ':\n",
    "            new_char = chr(((ord(char) - ord('A') + shift) % 26) + ord('A'))\n",
    "            encrypted_message += new_char\n",
    "        else:\n",
    "            raise ValueError(\"Повідомлення може містити лише великі латинські літери!\")\n",
    "    return encrypted_message\n",
    "\n",
    "try:\n",
    "    message = input(\"Введіть повідомлення для зашифрування(лише великі латинські літери): \").upper()\n",
    "    encrypted = caesar_cipher(message)\n",
    "    print(\"Зашифроване повідомлення:\", encrypted)\n",
    "except ValueError as e:\n",
    "    print(e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "472fa792-028c-4338-82ed-db282e66ce80",
   "metadata": {},
   "outputs": [],
   "source": [
    "Введіть повідомлення для зашифрування(лише великі латинські літери): >? HELLO WORLD\n",
    "Зашифроване повідомлення: IFMMPUXPSME"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d5ce4ba3-5cde-49bf-a94b-9406fa976874",
   "metadata": {},
   "source": [
    "### Приклад 4"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0f29030a-e009-4545-94f2-1f7a29cf742e",
   "metadata": {},
   "outputs": [],
   "source": [
    "Напишить програму для дешифрування повідомлення, зашифрованого шифром Цезара."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ae085267-ef2f-4c21-84d0-f5f88d7748ec",
   "metadata": {},
   "outputs": [],
   "source": [
    "def caesar_decipher(encrypted_message, shift=1):\n",
    "    decrypted_message = \"\"\n",
    "    for char in encrypted_message:\n",
    "        if 'A' <= char <= 'Z':\n",
    "            new_char = chr(((ord(char) - ord('A') - shift) % 26) + ord('A'))\n",
    "            decrypted_message += new_char\n",
    "        elif char == ' ':\n",
    "            decrypted_message += char\n",
    "        else:\n",
    "            raise ValueError(\"Повідомлення може містити лише великі латинські літери!\")\n",
    "    return decrypted_message\n",
    "\n",
    "try:\n",
    "    encrypted_message = input(\"Введіть повідомлення для розшифрування (лише великі латинські літери та пробіли): \").upper()\n",
    "    decrypted = caesar_decipher(encrypted_message)\n",
    "    print(\"Розшифроване повідомлення:\", decrypted)\n",
    "except ValueError as e:\n",
    "    print(e)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6bc90d51-3166-425f-a164-5a8f65d810c2",
   "metadata": {},
   "outputs": [],
   "source": [
    "Введіть повідомлення для розшифрування (лише великі латинські літери та пробіли): >? IFMMP XPSME\n",
    "Розшифроване повідомлення: HELLO WORLD"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0d0b443f-f3d6-4164-959e-a4d744ca80eb",
   "metadata": {},
   "source": [
    "### Завдання 1"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c2b29a70-eb5b-4c0e-a544-a32ffeee1e42",
   "metadata": {},
   "source": [
    "Ви вже знайомі з шифром Цезаря, і тому ми хочемо, щоб Ви покращили код, який ми нещодавно показували.\n",
    "\n",
    "Вихідний шифр Цезаря зрушує кожен символ однією: a стає b, z стає a, тощо. Давайте зробимо його трохи складнішим і дозволимо зміщеному значенню вийти з діапазону 1-25 включно.\n",
    "\n",
    "Крім того, нехай код зберігає регістр літер (малі літери залишаться малими), а всі неалфавітні символи повинні залишитися без змін.\n",
    "\n",
    "Ваше завдання - написати програму, яка:\n",
    "\n",
    "запитує у користувача рядок, який треба зашифрувати; запитує користувача значення зсуву (ціле число з діапазону 1-25 - примітка: Ви повинні змусити користувача ввести дійсне значення зсуву (не здавайтеся і не дозволяйте некоректним даним обдурити Вас); друкує закодований текст. Протестуйте свій код, використовуючи надані нами дані."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b133d3ef-ccbc-4fa1-915b-98791e72a8a0",
   "metadata": {},
   "outputs": [],
   "source": [
    "def caesar_cipher(message, shift):\n",
    "    encrypted_message = \"\"\n",
    "    for char in message:\n",
    "        if char.isalpha():\n",
    "            offset = 65 if char.isupper() else 97\n",
    "            new_char = chr(((ord(char) - offset + shift) % 26) + offset)\n",
    "            encrypted_message += new_char\n",
    "        else:\n",
    "            encrypted_message += char\n",
    "    return encrypted_message\n",
    "\n",
    "def get_valid_shift():\n",
    "    while True:\n",
    "        try:\n",
    "            shift = int(input(\"Введіть значення зсуву (ціле число з діапазону 1-25): \"))\n",
    "            if 1 <= shift <= 25:\n",
    "                return shift\n",
    "            else:\n",
    "                print(\"Будь ласка, введіть число в діапазоні від 1 до 25.\")\n",
    "        except ValueError:\n",
    "            print(\"Неправильний ввід. Будь ласка, введіть ціле число.\")\n",
    "\n",
    "try:\n",
    "    message = input(\"Введіть повідомлення для зашифрування: \")\n",
    "    shift = get_valid_shift()\n",
    "    encrypted = caesar_cipher(message, shift)\n",
    "    print(\"Зашифроване повідомлення:\", encrypted)\n",
    "except Exception as e:\n",
    "    print(\"Сталася помилка:\", e)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "51de954a-30ba-4067-bacf-9aef4cd5cae9",
   "metadata": {},
   "outputs": [],
   "source": [
    "Введіть повідомлення для зашифрування: >? Hello, World!\n",
    "Введіть значення зсуву (ціле число з діапазону 1-25): >? 3\n",
    "Зашифроване повідомлення: Khoor, Zruog!"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "00bfb5c9-c5c5-44a8-83dd-26b40d1c5291",
   "metadata": {},
   "source": [
    "## Контрольні запитання"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "02e75728-aea2-451a-88f4-7b595ff0096d",
   "metadata": {},
   "source": [
    "1. Який із наступних рядків описує справжню умову?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "584fa95a-e818-427f-b178-74bc669165d9",
   "metadata": {},
   "outputs": [],
   "source": [
    "'smith' > 'Smith'\n",
    "'Smiths' < 'Smith'\n",
    "'Smith' > '1000'\n",
    "'11' < '8'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "30451ab0-f889-4b82-8e37-038f36735c45",
   "metadata": {},
   "outputs": [],
   "source": [
    "Умови правильні!"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f4db7aed-4472-4cd2-bfdd-53bf0efc3325",
   "metadata": {},
   "source": [
    "2. Який очікуваний результат наступного коду?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ea907be2-e36d-45ec-b396-21cbce4a09f6",
   "metadata": {},
   "outputs": [],
   "source": [
    "s1 = 'Where are the snows of yesteryear'\n",
    "s2 = s1.split()\n",
    "s3 = sorted(s2)\n",
    "print(s3[1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cf78f4aa-8e73-41c7-96fa-b3cdf357a158",
   "metadata": {},
   "outputs": [],
   "source": [
    "are"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f5293b38-3ab0-4cb3-8ee4-a7616654c471",
   "metadata": {},
   "outputs": [],
   "source": [
    "3. Який очікуваний результат наступного коду?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4abd9a94-0a76-4924-929a-8fde5302a896",
   "metadata": {},
   "outputs": [],
   "source": [
    "s1 = '12.8'\n",
    "i = int(s1)\n",
    "s2 = str(i)\n",
    "f = float(s2)\n",
    "print(s1 == s2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ee3c8b73-cc1b-4d10-8847-16277fc3b943",
   "metadata": {},
   "outputs": [],
   "source": [
    "ValueError"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "455e6dee-9051-48e7-94b9-2281b9c5ec39",
   "metadata": {},
   "source": [
    "Перероблений код"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1cb53f54-2038-4acb-892a-141ac140c489",
   "metadata": {},
   "outputs": [],
   "source": [
    "s1 = '12.8'\n",
    "f = float(s1)  # Перетворення в число з плаваючою точкою\n",
    "i = int(f)     # Перетворення в ціле число\n",
    "s2 = str(i)    # Перетворення назад в рядок\n",
    "print(s1 == s2)  # Порівняння рядків\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e708daeb-926c-49b5-87a8-f41d9eeda0b2",
   "metadata": {},
   "outputs": [],
   "source": [
    "False"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "adab5636-03c4-4c3e-bb12-00093eada91a",
   "metadata": {},
   "source": [
    "## References"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d5024e50-324a-4587-9ab1-3b390b777862",
   "metadata": {},
   "source": [
    "1. Методичні вказівки\n",
    "2. Лекції\n",
    "3. https://uk.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80_%D0%A6%D0%B5%D0%B7%D0%B0%D1%80%D1%8F"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
